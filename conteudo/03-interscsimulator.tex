%!TeX root=../tese.tex
%("dica" para o editor de texto: este arquivo é parte de um documento maior)
% para saber mais: https://tex.stackexchange.com/q/78101

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{O InterSCSimulator}
\label{chap:interscsimulator}

% **4.1 Visão Geral da Ferramenta**
% * [cite_start]**Origem e Propósito:** Apresentar o *InterSCSimulator*, desenvolvido por Santana[cite: 34], como um simulador de cidades inteligentes, open-source e de larga escala.

% * [cite_start]**Arquitetura Técnica:** Explicar brevemente a escolha da linguagem **Erlang** e o **Modelo de Atores** (Actor Model)[cite: 101]. [cite_start]Destacar por que isso é vital para simular milhões de agentes (carros, pedestres, etc.) simultaneamente em "super real-time"[cite: 104].

O InterSCSimulator é um simulador de código aberto voltado para Cidades Inteligentes, projetado especificamente para lidar com cenários de grande escala. A ferramenta foi desenvolvida para representar a complexidade de um ambiente urbano real, incluindo o tráfego de veículos, o deslocamento de pedestres, o sistema de transporte público (como ônibus e metrô) e redes de sensores. O principal objetivo do simulador é permitir a execução de cenários realistas que possam auxiliar tanto pesquisadores quanto gestores públicos na tomada de decisões. Uma de suas características mais importantes é a capacidade de gerenciar milhões de agentes simultaneamente, o que possibilita a representação detalhada da mobilidade em grandes metrópoles.

Para atingir esse nível de desempenho, o simulador utiliza a linguagem de programação Erlang e baseia-se no Modelo de Atores. Nessa abordagem, cada elemento da simulação, um carro, um pedestre ou um sensor, atua como uma unidade independente (um ator) que se comunica com os outros por meio de trocas de mensagens. Essa arquitetura é essencial para garantir que o sistema consiga processar o enorme volume de interações que ocorrem no trânsito de uma cidade como São Paulo. Graças a essa estrutura, o InterSCSimulator consegue executar cenários com mais de 20 milhões de agentes de forma eficiente, muitas vezes em velocidade superior ao tempo real.

% * [cite_start]**Modelo de Tráfego:** Descrever o modelo mesoscópico utilizado (filas e densidade de vias)[cite: 848], que permite simular o fluxo da cidade sem o peso computacional de calcular a física de cada veículo individualmente.

% O InterSCSimulator utiliza um modelo de simulação de tráfego mesoscópico, o que é um ponto de otimização crucial para lidar com cenários de larga escala. O modelo mesoscópico simula cada veículo individualmente, mas, diferentemente dos modelos microscópicos (que exigem alto custo computacional por detalhar a interação entre veículos e o comportamento de direção), ele simplifica o cálculo da velocidade. A velocidade de um veículo em uma via é determinada por uma função de densidade que relaciona a capacidade da rua e o número de veículos presentes. Essa abordagem é mais adequada para a simulação de grandes áreas urbanas, como regiões metropolitanas, pois permite modelar o fluxo da cidade de forma eficiente, sem o peso computacional de calcular a física detalhada de cada veículo individualmente.

\section{Gerenciador de eventos}
\label{sec:gerenciador-eventos}

% **4.2 A Gestão de Eventos de Trânsito (Trabalhos Relacionados)**
% * [cite_start]**O Conceito de Events Manager:** Detalhar a contribuição de Lucas Kanashiro [cite: 2953] que introduziu o agente `Events Manager` e a capacidade de alterar o grafo da cidade em tempo de execução.
% * [cite_start]**Mecanismo de Interdição:** Explicar como o simulador processa arquivos estáticos (`events.xml`) para remover arestas (fechar ruas) ou reduzir capacidades em horários pré-agendados[cite: 3813, 3814].
% * *Conexão:* Ressaltar que essa infraestrutura foi fundamental, mas que ela dependia de um agendamento manual e estático dos eventos.

% **4.3 Modelagem e Ingestão de Dados Pluviométricos (Sua Contribuição)**
% * **O Parser de Chuva (`RainfallParser`):** Descrever o módulo que você desenvolveu para ler os dados reais de precipitação (o arquivo `rain.csv` gerado no Cap. 3).
% * **O Parser de Alagamentos (`FloodParser`):** Explicar como o sistema lê o arquivo de capacidades das vias (`roads-rain-capacity.csv`), associando IDs de arestas a limites de chuva em mm.
% * **Sincronização Temporal:** Explicar como o "relógio" da simulação consulta esses dados a cada passo de tempo (tick) para verificar o acúmulo de chuva.

% **4.4 Dinâmica de Alagamentos e Adaptação dos Agentes**
% * **O Ciclo de Feedback Climático:**
%     1.  Chuva acumulada supera a capacidade da via.
%     2.  Disparo automático de um evento de fechamento (utilizando a infraestrutura do `Events Manager`).
%     3.  A via torna-se intransitável no grafo.
% * **Comportamento dos Agentes (Re-routing):** Descrever como os carros reagem ao encontrar uma via fechada por alagamento. [cite_start]Diferenciar do comportamento padrão (onde eles ficariam parados) para o comportamento adaptativo (recálculo de rota)[cite: 3348].

% **4.5 Configuração e Execução do Experimento**
% * [cite_start]**Ambiente de Execução:** Mencionar brevemente a configuração técnica utilizada para rodar o experimento (Docker, Erlang VM)[cite: 3644].
% * **Saídas e Métricas:** Descrever quais dados o simulador gera (arquivos de log, `output.xml`) que permitirão a análise dos impactos (tempo de viagem, etc.) no próximo capítulo.

% ---

% 2.  **Imagens/Diagramas:**
%     * [cite_start]Recomendo fortemente incluir um diagrama atualizado da arquitetura (similar à Figura 4.1 da tese do Eduardo [cite: 887]), mas adicionando as caixinhas dos seus novos módulos (`RainfallParser`, `FloodParser`) conectados ao `Events Manager`. Isso visualiza perfeitamente a sua contribuição.

% Esse esqueleto cobre todo o percurso técnico e deixa claro qual é o "ombro de gigantes" em que você se apoiou e onde está a sua inovação. Pronta para começar o texto da seção 4.1?