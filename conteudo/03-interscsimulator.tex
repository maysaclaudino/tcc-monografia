%!TeX root=../tese.tex
%("dica" para o editor de texto: este arquivo é parte de um documento maior)
% para saber mais: https://tex.stackexchange.com/q/78101

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{O InterSCSimulator}
\label{chap:interscsimulator}

% **4.1 Visão Geral da Ferramenta**
% * [cite_start]**Origem e Propósito:** Apresentar o *InterSCSimulator*, desenvolvido por Santana[cite: 34], como um simulador de cidades inteligentes, open-source e de larga escala.

% * [cite_start]**Arquitetura Técnica:** Explicar brevemente a escolha da linguagem **Erlang** e o **Modelo de Atores** (Actor Model)[cite: 101]. [cite_start]Destacar por que isso é vital para simular milhões de agentes (carros, pedestres, etc.) simultaneamente em "super real-time"[cite: 104].

O InterSCSimulator é um simulador de código aberto voltado para Cidades Inteligentes, projetado especificamente para lidar com cenários de grande escala. A ferramenta foi desenvolvida para representar a complexidade de um ambiente urbano real, incluindo o tráfego de veículos, o deslocamento de pedestres, o sistema de transporte público (como ônibus e metrô) e redes de sensores. O principal objetivo do simulador é permitir a execução de cenários realistas que possam auxiliar tanto pesquisadores quanto gestores públicos na tomada de decisões. Uma de suas características mais importantes é a capacidade de gerenciar milhões de agentes simultaneamente, o que possibilita a representação detalhada da mobilidade em grandes metrópoles.

Para atingir esse nível de desempenho, o simulador utiliza a linguagem de programação Erlang e baseia-se no Modelo de Atores. Nessa abordagem, cada elemento da simulação, um carro, um pedestre ou um sensor, atua como uma unidade independente (um ator) que se comunica com os outros por meio de trocas de mensagens. Essa arquitetura é essencial para garantir que o sistema consiga processar o enorme volume de interações que ocorrem no trânsito de uma cidade como São Paulo. Graças a essa estrutura, o InterSCSimulator consegue executar cenários com mais de 20 milhões de agentes de forma eficiente, muitas vezes em velocidade superior ao tempo real.

% * [cite_start]**Modelo de Tráfego:** Descrever o modelo mesoscópico utilizado (filas e densidade de vias)[cite: 848], que permite simular o fluxo da cidade sem o peso computacional de calcular a física de cada veículo individualmente.

% O InterSCSimulator utiliza um modelo de simulação de tráfego mesoscópico, o que é um ponto de otimização crucial para lidar com cenários de larga escala. O modelo mesoscópico simula cada veículo individualmente, mas, diferentemente dos modelos microscópicos (que exigem alto custo computacional por detalhar a interação entre veículos e o comportamento de direção), ele simplifica o cálculo da velocidade. A velocidade de um veículo em uma via é determinada por uma função de densidade que relaciona a capacidade da rua e o número de veículos presentes. Essa abordagem é mais adequada para a simulação de grandes áreas urbanas, como regiões metropolitanas, pois permite modelar o fluxo da cidade de forma eficiente, sem o peso computacional de calcular a física detalhada de cada veículo individualmente.

\section{A Gestão de Eventos de Trânsito}
\label{sec:gerenciador-eventos}

% **4.2 A Gestão de Eventos de Trânsito (Trabalhos Relacionados)**
% * [cite_start]**O Conceito de Events Manager:** Detalhar a contribuição de Lucas Kanashiro [cite: 2953] que introduziu o agente `Events Manager` e a capacidade de alterar o grafo da cidade em tempo de execução.
% * [cite_start]**Mecanismo de Interdição:** Explicar como o simulador processa arquivos estáticos (`events.xml`) para remover arestas (fechar ruas) ou reduzir capacidades em horários pré-agendados[cite: 3813, 3814].
% * *Conexão:* Ressaltar que essa infraestrutura foi fundamental, mas que ela dependia de um agendamento manual e estático dos eventos.

Para possibilitar a experimentação de cenários mais complexos, como acidentes de trânsito ou interdições programadas, foi necessário criar mecanismos que pudessem alterar a infraestrutura da cidade durante a simulação. Essa funcionalidade foi desenvolvida por Lucas Kanashiro Duarte em sua pesquisa de mestrado, através da implementação do agente Events Manager. Este agente é responsável por gerenciar eventos de trânsito, programando intervenções e modificando o grafo da cidade em tempo de execução. Essa característica é essencial para garantir o realismo da simulação, já que, no mundo real, a malha viária sofre alterações constantes devido a incidentes ou obras.

O funcionamento dessa gestão de eventos baseia-se na leitura de um arquivo de configuração estático, chamado events.xml, que lista as intervenções a serem realizadas. O simulador utiliza esse arquivo para agendar as modificações nos ciclos de tempo definidos. O sistema permite simular o fechamento total de vias, removendo temporariamente a aresta correspondente do grafo (close\_street) e impedindo a passagem de veículos. Além disso, é possível simular a redução da capacidade de uma via (reduce\_capacity), ajustando o fluxo permitido para uma porcentagem menor, o que reduz a velocidade dos carros naquele trecho.

Apesar de o gerenciador de eventos ter criado a base necessária para alterar o mapa da cidade, ele dependia originalmente de um agendamento manual. Para simular um bloqueio, era preciso saber com antecedência e definir no arquivo events.xml exatamente qual rua fecharia e quando. Essa abordagem funcionava bem para situações controladas, mas não permitia relacionar diretamente o acúmulo de chuva com a interdição das ruas. Este trabalho resolve essa limitação automatizando a criação desses eventos de bloqueio a partir do processamento de dados reais de chuva, como veremos a seguir.

\section{A Modelagem de Eventos Pluviométricos}
\label{sec:modelagem-eventos-pluviometricos}

% **4.3 Modelagem e Ingestão de Dados Pluviométricos (Sua Contribuição)**
% * **O Parser de Chuva (`RainfallParser`):** Descrever o módulo que você desenvolveu para ler os dados reais de precipitação (o arquivo `rain.csv` gerado no Cap. 3).
% * **O Parser de Alagamentos (`FloodParser`):** Explicar como o sistema lê o arquivo de capacidades das vias (`roads-rain-capacity.csv`), associando IDs de arestas a limites de chuva em mm.
% * **Sincronização Temporal:** Explicar como o "relógio" da simulação consulta esses dados a cada passo de tempo (tick) para verificar o acúmulo de chuva.

Para resolver a dependência de agendamentos manuais, implementamos um mecanismo de pré-processamento que transforma dados climáticos brutos em eventos de trânsito para o simulador. O processo começa com a leitura dos dados: o sistema lê o arquivo rain.csv e guarda a série temporal de chuvas em uma lista na memória. Em seguida, lê o arquivo roads-rain-capacity.csv e armazena em outra lista os limites de chuva que cada via suporta antes de alagar.

Com essas estruturas carregadas, o simulador cruza as informações para criar a lista de eventos de alagamento. A lógica utiliza uma janela de tempo deslizante: o sistema calcula a chuva acumulada nas últimas 3 horas para cada momento registrado no arquivo de chuvas. Se esse volume acumulado for maior que a capacidade suportada pela via, é criado automaticamente um evento de fechamento (close\_street) para os trechos daquela rua, com uma duração padrão de 2 horas.

Um ponto importante resolvido nesta etapa foi o tratamento de eventos sobrepostos. Existem situações em que uma chuva forte e constante pode manter uma rua alagada por um período maior que a duração padrão. Para lidar com isso, o agente Events Manager foi alterado. Em vez de tentar fechar uma rua que já está fechada, o gerenciador verifica o estado da via: se um novo alagamento é detectado para um trecho já bloqueado, o sistema adia o horário de sua reabertura. Dessa forma, o bloqueio continua ativo enquanto as condições de chuva permanecerem críticas.

Por fim, os eventos de alagamento gerados dinamicamente são unidos aos eventos estáticos do arquivo events.xml, formando uma lista única de intervenções na cidade. Quando um desses eventos é ativado durante a simulação, a aresta correspondente à via alagada é removida temporariamente do grafo. A consequência é que essa via deixa de ser considerada como um caminho possível. O agente (carro), ao se deparar com essa remoção ou ao planejar seu trajeto, é forçado a recalcular sua rota. O sistema então busca o menor caminho até o destino a partir da posição atual do veículo, utilizando apenas as ruas que não estão interditadas.

\begin{figure}
    \centering
    \includegraphics[width=\paperwidth]{imagens/diagramas/fluxo-interdicao-vias.png}
    \caption{Fluxo de interdição de ruas na simulação.}
    \label{fig:fluxo-interdicao-vias}
\end{figure}

% **4.5 Configuração e Execução do Experimento**
% * [cite_start]**Ambiente de Execução:** Mencionar brevemente a configuração técnica utilizada para rodar o experimento (Docker, Erlang VM)[cite: 3644].
% * **Saídas e Métricas:** Descrever quais dados o simulador gera (arquivos de log, `output.xml`) que permitirão a análise dos impactos (tempo de viagem, etc.) no próximo capítulo.

% ---

% 2.  **Imagens/Diagramas:**
%     * [cite_start]Recomendo fortemente incluir um diagrama atualizado da arquitetura (similar à Figura 4.1 da tese do Eduardo [cite: 887]), mas adicionando as caixinhas dos seus novos módulos (`RainfallParser`, `FloodParser`) conectados ao `Events Manager`. Isso visualiza perfeitamente a sua contribuição.
